import os
import numpy as np
import pandas as pd
import tensorflow as tf


class ReconstructionErrorExplainer:
    """
    Decomposed an Autoencoders reconstruction error into:
        - Feature-level errors
        - Percentage contribution per feature
        - Optional behavioral group-level aggregation
    """
    
    def __init__(self, feature_names: list, feature_groups: dict | None=None) -> None:
        """
        Initializes the explainer.
        
        Args:
            feature_names: An ordered list of feature names matching model input order
            feature_groups: A dictionary mapping of group names to feature names
            
        Returns:
            None:
        """
        self.feature_names = feature_names
        self.feature_groups = feature_groups
        self.feature_index_map = {name:idx for idx, name in enumerate(feature_names)}
        
        
    def compute_feature_error(self, input_data: np.ndarray, reconstructed_data: np.ndarray) -> np.ndarray:
        """
        Computes squared reconstruction error per feature.
        
        Args:
            input_data: The original input features of shape: (n_samples, n_features)
            reconstructed_data: The reconstructed features generated by autoencoders of shape: (n_samples, n_features)
            
        Returns:
            np.ndarray: The squared error per feature of shape: (n_samples, n_features)
        """
        return np.square(input_data - reconstructed_data)
    
    
    def compute_total_error(self, feature_error: np.ndarray) -> np.ndarray:
        """
        Computes the total reconstruction error per sample.
        
        Args:
            feature_error: An array containing feature-level errors
            
        Returns:
            np.ndarray: The total reconstruction error per sample
        """
        return np.sum(feature_error, axis=1)
    
    
    def compute_contribution_ratio(self, feature_error: np.ndarray, total_error: np.ndarray) -> np.ndarray:
        """
        Computes the percentage contributions fo each feature to the total error.
        
        Args:
            feature_error: An array containing feature-level errors
            total_errors: An array containing total reconstruction error per sample
            
        Returns:
            np.ndarray: The contribition ratio of the shape: (n_samples, n_features)
        """
        # Ensuring there's no division by 0
        total_error_safe = np.where(total_error == 0, 1e-8, total_error)
        
        contribution_ratio = feature_error / total_error_safe[:, np.newaxis]
        return contribution_ratio
    
    
    def compute_group_error(self, feature_error: np.ndarray) -> np.ndarray | None:
        """
        Aggregates feature errors by behavioral groups.
        
        Args:
            feature_error: An array containing feature-level errors
            
        Returns:
            np.ndarray: An aggregate array of shape: (n_samples, n_groups)
        """
        if self.feature_groups is None:
            return None
        
        group_errors = []
        
        for group, features in self.feature_groups.items():
            indices = [self.feature_index_map[f] for f in features if f in self.feature_index_map]
            
            group_error = np.sum(feature_error[:, indices], axis=1)
            group_errors.append(group_error)
            
        return np.vstack(group_errors).T
    
    
    def explain(self, input_data: np.ndarray, model: tf.keras.Model) -> dict:
        """
        Generates a full reconstruction explaination.
        
        Args:
            input_data: The input data
            model: A trained autoencoder model
            
        Returns:
            dict: A dictionary containing feature error, total error, contribution ration, and group error
        """
        x_pred = model.predict(input_data, verbose=0)
        
        feature_error = self.compute_feature_error(input_data, x_pred)
        total_error = self.compute_total_error(feature_error)
        contribution_ratio = self.compute_contribution_ratio(feature_error, total_error)
        group_error = self.compute_group_error(feature_error)
        
        error_dict = {
            "feature_error": feature_error,
            "total_error": total_error,
            "contribution_ratio": contribution_ratio,
            "group_error": group_error
        }
        
        return error_dict
    
    
    def explain_to_df(self, input_data: np.ndarray, model: tf.keras.Model, metadata: pd.DataFrame | None=None, include_feat_err: bool=True, include_contributions: bool=True) -> pd.DataFrame:
        """
        Generates a structured Pandas DataFrame containing reconstruction explainations.
        
        Args:
            input_data: The scaled input data
            model: A trained autoencoder model
            metadata: Optional metadata columns
            include_feat_err: Includes raw per-feature reconstruction errors
            include_contributions: Inlcudes per-feature contribution ratios
            
        Returns:
            pd.DataFrame: A structured DataFrame containing metadata, total error, group-level errors, and optional feature-level details
        """
        # Computing reconstruction explainations
        results = self.explain(input_data, model)
        
        feature_error = results["feature_error"]
        total_error = results["total_error"]
        contribution_ratio = results["contribution_ratio"]
        group_error = results["group_error"]
        
        error_df = pd.DataFrame()
        
        # Adding metadata
        if metadata is not None:
            error_df = metadata.reset_index(drop=True).copy()
            
        # Add total reconstruction error
        error_df["total_reconstruction_error"] = total_error
            
        # Adding group-level errors if defined
        if (self.feature_groups is not None) and (group_error is not None):
            for idx, group in enumerate(self.feature_groups.keys()):
                error_df[f"group_error_{group}"] = group_error[:, idx]
                
        # Adding feature-level errors if true
        if include_feat_err:
            for idx, feature in enumerate(self.feature_names):
                error_df[f"error_{feature}"] = feature_error[:, idx]
                
        # Adding contribution ratios if true
        if include_contributions:
            for idx, feature in enumerate(self.feature_names):
                error_df[f"contribution_{feature}"] = contribution_ratio[:, idx]
                
        return error_df